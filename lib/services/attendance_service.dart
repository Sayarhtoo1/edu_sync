import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:edu_sync/models/attendance.dart' as app_attendance;
import 'package:intl/intl.dart'; // For date formatting if needed

class AttendanceService {
  final SupabaseClient _supabaseClient = Supabase.instance.client;

  // Fetch attendance for a specific class on a specific date
  Future<Map<int, String>> getAttendanceForClassDate(int classId, DateTime date) async { // Corrected to int
    final dateString = DateFormat('yyyy-MM-dd').format(date);
    Map<int, String> statuses = {};
    try {
      final response = await _supabaseClient
          .from('attendance')
          .select('student_id, status') // Fetch the 'status' string directly
          .eq('class_id', classId)
          .eq('date', dateString);

      for (var record in response) {
        statuses[record['student_id'] as int] = record['status'] as String? ?? 'Present'; // Default to 'Present' if status is null
      }
      return statuses;
    } catch (e) {
      print('Error fetching attendance for class $classId on $dateString: $e');
      return statuses; // Return empty or partially filled map on error
    }
  }

  // Save a batch of attendance records
  // Assumes app_attendance.Attendance model has a toMap() method
  Future<bool> saveAttendanceBatch(List<app_attendance.Attendance> attendanceBatch) async {
    if (attendanceBatch.isEmpty) return true; // Nothing to save

    try {
      // Supabase upsert can be useful here if records might already exist for a student/date
      // and you want to update them. Or use insert with ON CONFLICT.
      // For simplicity, using insert. Ensure your DB schema handles conflicts (e.g., UNIQUE constraint on student_id, class_id, date).
      
      List<Map<String, dynamic>> recordsToInsert = [];
      for (var entry in attendanceBatch) {
        // Assuming your Attendance model's toMap() prepares data correctly for Supabase
        // and handles the conversion of status string ('Present', 'Absent', 'Late') to DB fields (e.g., is_present boolean, status_enum)
        // For this example, let's assume toMap() creates a map compatible with the 'attendance' table schema.
        // The 'id' should typically be auto-generated by the DB, so remove it if present.
        var map = entry.toMap();
        map.remove('id'); // Ensure ID is not sent for insert if it's auto-incrementing
        
        // Convert 'Present', 'Absent', 'Late' to DB representation if needed
        // Example: if DB has 'is_present' (boolean) and 'status_detail' (text for 'Late')
        // String status = map.remove('status_string_from_model'); // if your model has this
        // map['is_present'] = (status == 'Present' || status == 'Late');
        // if (status == 'Late') map['status_detail'] = 'Late'; else map['status_detail'] = null;

        recordsToInsert.add(map);
      }

      // Using upsert to handle existing records for the same student, class, and date.
      // Requires a unique constraint on (student_id, class_id, date) in your DB.
      // Specify `onConflict` with the columns forming the unique constraint.
      await _supabaseClient.from('attendance').upsert(
        recordsToInsert,
        onConflict: 'student_id, class_id, date', // Replace with your actual unique constraint columns
      );
      return true;
    } catch (e) {
      print('Error saving attendance batch: $e');
      return false;
    }
  }

  // Fetch all attendance records for a specific student
  Future<List<app_attendance.Attendance>> getAttendanceForStudent(int studentId) async {
    try {
      final response = await _supabaseClient
          .from('attendance')
          .select()
          .eq('student_id', studentId)
          .order('date', ascending: false); // Order by date, most recent first
      
      return response.map((data) => app_attendance.Attendance.fromMap(data)).toList();
    } catch (e) {
      print('Error fetching attendance for student $studentId: $e');
      return [];
    }
  }
}
