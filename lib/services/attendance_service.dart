import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:edu_sync/models/attendance.dart' as app_attendance;
import 'package:intl/intl.dart'; // For date formatting if needed
import 'cache_service.dart';

class AttendanceService {
  final SupabaseClient _supabaseClient = Supabase.instance.client;
  final CacheService _cacheService = CacheService();

  // Fetch attendance for a specific class on a specific date
  Future<List<app_attendance.Attendance>> getAttendanceForClassByDate(int classId, DateTime date) async {
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      // Offline: Fetch from cache
      return await _cacheService.getAttendanceForClass(classId, date);
    } else {
      // Online: Fetch from Supabase and update cache
      final dateString = DateFormat('yyyy-MM-dd').format(date);
      try {
        final response = await _supabaseClient
            .from('attendance')
            .select()
            .eq('class_id', classId)
            .eq('date', dateString);

        final attendance = response.map((data) => app_attendance.Attendance.fromMap(data)).toList();
        await _cacheService.saveAttendanceForClass(classId, date, attendance);
        return attendance;
      } catch (e) {
        print('Error fetching attendance for class $classId on $dateString: $e');
        return await _cacheService.getAttendanceForClass(classId, date);
      }
    }
  }

  // Save a batch of attendance records
  // Assumes app_attendance.Attendance model has a toMap() method
  Future<bool> saveAttendanceBatch(List<app_attendance.Attendance> attendanceBatch) async {
    if (attendanceBatch.isEmpty) return true; // Nothing to save

    try {
      List<Map<String, dynamic>> recordsToInsert = [];
      for (var entry in attendanceBatch) {
        // The Attendance model's toMap() now correctly includes 'status' and excludes 'is_present'.
        // The 'id' should be auto-generated by the DB, so remove it if present in the map from toMap().
        var map = entry.toMap();
        // The toMap in the model already omits 'id', so no need to remove it here explicitly if that's consistent.
        // map.remove('id'); // This line might be redundant if toMap() already handles it.

        recordsToInsert.add(map);
      }

      // Using upsert to handle existing records for the same student, class, and date.
      // The unique constraint (student_id, class_id, date) is defined in supabase_schema.sql.
      await _supabaseClient.from('attendance').upsert(
        recordsToInsert,
        onConflict: 'student_id, class_id, date', 
      );
      return true;
    } catch (e) {
      print('Error saving attendance batch: $e');
      return false;
    }
  }

  // Fetch all attendance records for a specific student
  Future<List<app_attendance.Attendance>> getAttendanceForStudent(int studentId) async {
    try {
      final response = await _supabaseClient
          .from('attendance')
          .select()
          .eq('student_id', studentId)
          .order('date', ascending: false); // Order by date, most recent first
      
      return response.map((data) => app_attendance.Attendance.fromMap(data)).toList();
    } catch (e) {
      print('Error fetching attendance for student $studentId: $e');
      return [];
    }
  }
}
