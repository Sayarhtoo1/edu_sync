import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:edu_sync/models/attendance.dart' as app_attendance;
import 'package:intl/intl.dart'; // For date formatting if needed

class AttendanceService {
  final SupabaseClient _supabaseClient = Supabase.instance.client;

  // Fetch attendance for a specific class on a specific date
  Future<Map<int, String>> getAttendanceForClassDate(int classId, DateTime date) async { // Corrected to int
    final dateString = DateFormat('yyyy-MM-dd').format(date);
    Map<int, String> statuses = {};
    try {
      final response = await _supabaseClient
          .from('attendance')
          .select('student_id, status') // Fetch the 'status' string directly
          .eq('class_id', classId)
          .eq('date', dateString);

      for (var record in response) {
        statuses[record['student_id'] as int] = record['status'] as String? ?? 'Present'; // Default to 'Present' if status is null
      }
      return statuses;
    } catch (e) {
      print('Error fetching attendance for class $classId on $dateString: $e');
      return statuses; // Return empty or partially filled map on error
    }
  }

  // Save a batch of attendance records
  // Assumes app_attendance.Attendance model has a toMap() method
  Future<bool> saveAttendanceBatch(List<app_attendance.Attendance> attendanceBatch) async {
    if (attendanceBatch.isEmpty) return true; // Nothing to save

    try {
      List<Map<String, dynamic>> recordsToInsert = [];
      for (var entry in attendanceBatch) {
        // The Attendance model's toMap() now correctly includes 'status' and excludes 'is_present'.
        // The 'id' should be auto-generated by the DB, so remove it if present in the map from toMap().
        var map = entry.toMap();
        // The toMap in the model already omits 'id', so no need to remove it here explicitly if that's consistent.
        // map.remove('id'); // This line might be redundant if toMap() already handles it.

        recordsToInsert.add(map);
      }

      // Using upsert to handle existing records for the same student, class, and date.
      // The unique constraint (student_id, class_id, date) is defined in supabase_schema.sql.
      await _supabaseClient.from('attendance').upsert(
        recordsToInsert,
        onConflict: 'student_id, class_id, date', 
      );
      return true;
    } catch (e) {
      print('Error saving attendance batch: $e');
      return false;
    }
  }

  // Fetch all attendance records for a specific student
  Future<List<app_attendance.Attendance>> getAttendanceForStudent(int studentId) async {
    try {
      final response = await _supabaseClient
          .from('attendance')
          .select()
          .eq('student_id', studentId)
          .order('date', ascending: false); // Order by date, most recent first
      
      return response.map((data) => app_attendance.Attendance.fromMap(data)).toList();
    } catch (e) {
      print('Error fetching attendance for student $studentId: $e');
      return [];
    }
  }
}
