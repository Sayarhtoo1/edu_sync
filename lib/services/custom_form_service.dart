import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/custom_form.dart';
import '../models/form_field_item.dart';
import 'package:intl/intl.dart'; // Import DateFormat
import 'cache_service.dart';

class CustomFormService {
  final SupabaseClient _supabaseClient = Supabase.instance.client;
  final CacheService _cacheService = CacheService();

  // Create a new custom form and its fields in a transaction
  Future<CustomForm?> createCustomForm(CustomForm form, List<FormFieldItem> fields) async {
    try {
      // It's generally better to handle transactions server-side with an RPC function
      // for atomicity. Client-side "transactions" are a series of calls.
      // If any step fails, manual rollback/cleanup might be needed.

      // 1. Insert the form
      final formMap = form.toMap();
      // Remove fields that are auto-generated by DB or not part of this table directly
      formMap.remove('created_at'); 
      formMap.remove('updated_at');

      final formResponse = await _supabaseClient
          .from('custom_forms')
          .insert(formMap)
          .select()
          .single();
      
      final createdForm = CustomForm.fromMap(formResponse);

      // 2. Insert the fields, linking them to the created form
      if (fields.isNotEmpty) {
        final fieldMaps = fields.map((field) {
          final fieldMap = field.toMap();
          fieldMap['form_id'] = createdForm.id; // Link to the parent form
          fieldMap.remove('id'); // Assuming field IDs are also auto-generated or client-generated UUIDs
          return fieldMap;
        }).toList();

        await _supabaseClient.from('form_fields').insert(fieldMaps);
      }
      return createdForm;
    } catch (e) {
      print('Error creating custom form: $e');
      // Consider re-throwing or returning a more specific error type
      return null;
    }
  }

  Future<List<CustomForm>> getManageableForms(String userId, String userRole, int schoolId) async {
    // For Admins: fetch all forms for their schoolId
    // For Teachers: fetch forms created by them OR assigned to their classes (more complex, needs thought on assignment)
    // For now, let's assume teachers only manage forms they created.
    // CustomForm model needs school_id. Let's assume it will be added.
    // For now, this query might fail if school_id is not in CustomForm or the table.
    try {
      PostgrestFilterBuilder queryBuilder = _supabaseClient
          .from('custom_forms')
          .select();
          // .eq('school_id', schoolId); // This line needs CustomForm.school_id

      if (userRole == 'Teacher') {
        queryBuilder = queryBuilder.eq('created_by', userId); // Ensure this matches the DB column name
      }
      
      final List<dynamic> responseData = await queryBuilder.order('created_at', ascending: false);
      // The data from Supabase is List<Map<String, dynamic>>, but often typed as List<dynamic> initially.
      return responseData.map((data) => CustomForm.fromMap(data as Map<String, dynamic>)).toList();
    } catch (e) {
      print('Error fetching manageable forms: $e');
      return [];
    }
  }

  Future<List<CustomForm>> getCustomFormsForSchool(int schoolId) async {
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      return await _cacheService.getCustomFormsForSchool(schoolId);
    } else {
      try {
        final response = await _supabaseClient
            .from('custom_forms')
            .select()
            .eq('school_id', schoolId)
            .order('title', ascending: true);
        final forms = response.map((data) => CustomForm.fromMap(data)).toList();
        await _cacheService.saveCustomFormsForSchool(schoolId, forms);
        return forms;
      } catch (e) {
        print('Error fetching custom forms for school $schoolId: $e');
        return await _cacheService.getCustomFormsForSchool(schoolId);
      }
    }
  }

  Future<List<CustomForm>> getActiveFormsForStudent(int studentId, List<int> classIds, int schoolId, DateTime date) async { // studentId and classIds changed to int
    // This is complex due to multiple assignment types (whole school, class, student)
    // and date ranges/recurrence.
    // This might be best implemented as a Supabase RPC function (database function).
    // Client-side logic would be very convoluted.
    
    // Placeholder for client-side attempt (less efficient and complex):
    try {
      final String today = DateFormat('yyyy-MM-dd').format(date);
      final response = await _supabaseClient
          .from('custom_forms')
          .select()
          .eq('school_id', schoolId) // Assuming CustomForm has school_id
          .lte('active_from', today)
          .gte('active_to', today)
          // .eq('is_daily', true) // Or handle recurrence differently
          // This doesn't filter by assignment yet.
          .order('title', ascending: true);

      List<CustomForm> allActiveForms = response.map((data) => CustomForm.fromMap(data)).toList();
      List<CustomForm> relevantForms = [];

      for (var form in allActiveForms) {
        if (form.assignToWholeSchool) {
          relevantForms.add(form);
          continue;
        }
        // form.assignedStudentIds is List<int>, studentId is int
        if (form.assignedStudentIds.contains(studentId)) {
          relevantForms.add(form);
          continue;
        }
        // classIds is List<int>, form.assignedClassIds is List<int>
        if (classIds.any((classId) => form.assignedClassIds.contains(classId))) {
          relevantForms.add(form);
          continue;
        }
      }
      return relevantForms.toSet().toList(); // Ensure uniqueness
    } catch (e) {
      print('Error fetching active forms for student: $e');
      return [];
    }
  }

  Future<List<FormFieldItem>> getFormFields(String formId) async {
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      return await _cacheService.getFormFields(formId);
    } else {
      try {
        final response = await _supabaseClient
            .from('form_fields')
            .select()
            .eq('form_id', formId)
            .order('id'); // Or some other order if needed (e.g., a sequence/order column)
        final fields = response.map((data) => FormFieldItem.fromMap(data)).toList();
        await _cacheService.saveFormFields(formId, fields);
        return fields;
      } catch (e) {
        print('Error fetching form fields for form $formId: $e');
        return await _cacheService.getFormFields(formId);
      }
    }
  }

  Future<bool> updateCustomForm(CustomForm form, List<FormFieldItem> fieldsToAdd, List<String> fieldIdsToDelete, List<FormFieldItem> fieldsToUpdate) async {
    // This should ideally be a transaction or an RPC function.
    try {
      // 1. Update the form details
      final formMap = form.toMap();
      formMap.remove('created_at'); // Don't update created_at
      formMap.remove('id'); // Don't update id in the SET clause
      
      await _supabaseClient
          .from('custom_forms')
          .update(formMap)
          .eq('id', form.id);

      // 2. Delete fields marked for deletion
      if (fieldIdsToDelete.isNotEmpty) {
        for (String fieldId in fieldIdsToDelete) {
          await _supabaseClient
              .from('form_fields')
              .delete()
              .eq('id', fieldId);
        }
      }

      // 3. Update existing fields
      if (fieldsToUpdate.isNotEmpty) {
        for (var field in fieldsToUpdate) {
          final fieldMap = field.toMap();
          fieldMap.remove('id'); // Don't update id
          fieldMap.remove('form_id'); // form_id shouldn't change
          await _supabaseClient
              .from('form_fields')
              .update(fieldMap)
              .eq('id', field.id);
        }
      }

      // 4. Add new fields
      if (fieldsToAdd.isNotEmpty) {
        final newFieldMaps = fieldsToAdd.map((field) {
          final fieldMap = field.toMap();
          fieldMap['form_id'] = form.id;
          // fieldMap.remove('id'); // Assuming new field IDs are client-generated UUIDs or handled by DB
          return fieldMap;
        }).toList();
        await _supabaseClient.from('form_fields').insert(newFieldMaps);
      }
      return true;
    } catch (e) {
      print('Error updating custom form: $e');
      return false;
    }
  }

  Future<bool> deleteCustomForm(String formId) async {
    try {
      // Deleting a form should also delete its fields and responses due to CASCADE constraint
      await _supabaseClient.from('custom_forms').delete().eq('id', formId);
      return true;
    } catch (e) {
      print('Error deleting custom form $formId: $e');
      return false;
    }
  }
}
